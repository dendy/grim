
# Useful macros here.


# This Qt macro was already fixed in CMake 2.7.
# But while it will not be placed in main OSS repository
# we will use custom replacement for this macro.
#
# FindQt4.cmake incorrectly resolves path to intermediate files.

macro( QT4_MAKE_OUTPUT_FILE infile prefix ext outfile )
	string( LENGTH ${CMAKE_CURRENT_BINARY_DIR} _binlength )
	string( LENGTH ${infile} _infileLength )
	set( _checkinfile ${CMAKE_CURRENT_SOURCE_DIR} )
	if( _infileLength GREATER _binlength )
		string( SUBSTRING "${infile}" 0 ${_binlength} _checkinfile )
	endif( _infileLength GREATER _binlength )
	if( CMAKE_CURRENT_BINARY_DIR MATCHES "${_checkinfile}" )
		file( RELATIVE_PATH rel ${CMAKE_CURRENT_BINARY_DIR} ${infile} )
	else( CMAKE_CURRENT_BINARY_DIR MATCHES "${_checkinfile}" )
		file( RELATIVE_PATH rel ${CMAKE_CURRENT_SOURCE_DIR} ${infile} )
	endif( CMAKE_CURRENT_BINARY_DIR MATCHES "${_checkinfile}" )

	# now rel in form of ../../src/myheader.h
	# convert it to	  __/__/src/myheader.h
	string( REPLACE ".." "__" rel ${rel} )

	set( _outfile "${CMAKE_CURRENT_BINARY_DIR}/Qt4TemporaryFiles/${rel}" )

	get_filename_component( outpath ${_outfile} PATH )
	get_filename_component( _outfile ${_outfile} NAME_WE )

	file( MAKE_DIRECTORY ${outpath} )
	set( ${outfile} ${outpath}/${prefix}${_outfile}.${ext} )
endmacro( QT4_MAKE_OUTPUT_FILE )




# Macro for creating rules to generate Qt translations.
#
# Usage:
#
#   grim_create_translation( QM_FILE TS_TARGETS TS_FILE [source1 source2 ...] )
#
#   - QM_FILE    - out variable, here will be generated .qm file
#   - TS_TARGETS - out variable, here will be added target to update .ts file
#   - TS_FILE    - in variable, pass .ts file to update and from which .qm file should be generated
#
# Two steps here, each can be done separately:
# 1. Update .ts files from sources/forms
# 2. Generate .qm files from .ts files
#
# This macro also workarounds CMake issue, when .ts files treats as compilation
# product and will be physically removed from drive on "make clean" step.
#
# .ts files are not compilation products, they are not generated inside build
# directory. .qm files does - they could be completely removed on "make clean".
#
# Because .ts files should be created separately and should be not included
# into build step - separate target should be created separately by user for convenience.
#
# Example:
#
#   grim_create_translation( qm_file ts_targets myapp.ts mysource.cpp myform.ui ... )
#   add_custom_target( update_my_translations DEPENDS ${ts_targets} )
#
# Updating .ts files can be issued in two ways:
# 1. run "make update_my_translations" (recommended)
# 2. add update_my_translations target as dependency to build process, this will issue .ts
#    updates automatically each time build runs.

macro( grim_create_translation QM_FILE OUTPUT_PATH TS_TARGETS TS_FILE )
	qt4_extract_options( _source_files _lupdate_options ${ARGN} )

	get_filename_component( _ts_file_absolute "${TS_FILE}" ABSOLUTE )

	set( _pro_file )
	set( _dummy_target_file )

	get_filename_component( _ts_filename "${TS_FILE}" NAME )
	get_filename_component( _ts_filename_we "${TS_FILE}" NAME_WE )

	set( _output_path "${OUTPUT_PATH}" )
	if ( _output_path )
		get_filename_component( _output_dir "${OUTPUT_PATH}" PATH )
		set( _pro_file "${CMAKE_CURRENT_BINARY_DIR}/${_output_dir}/${_ts_filename_we}.pro" )
		set( _dummy_target_file "${CMAKE_CURRENT_BINARY_DIR}/${_output_dir}/_dummy_target_file_for_${_ts_filename_we}" )
	else ( _output_path )
		set( _pro_file "${CMAKE_CURRENT_BINARY_DIR}/${_ts_filename_we}.pro" )
		set( _dummy_target_file "${CMAKE_CURRENT_BINARY_DIR}/_dummy_target_file_for_${_ts_filename_we}" )
	endif ( _output_path )

	if ( _source_files )
		# generate .pro file for lupdate utility

		file( WRITE "${_pro_file}"
			"#\n"
			"# This file is autogenerated by grim_create_translation() macro\n"
			"# to update translation file: ${_ts_filename}\n"
			"# All changes will be lost\n"
			"\n"
			"SOURCES =\\\n"
			)
		foreach ( _source_file ${_source_files} )
			file( APPEND "${_pro_file}" "  ${_source_file}\\\n" )
		endforeach ( _source_file ${_source_files} )
	endif ( _source_files )

	# create command with invalid output file so it will be never cleared and always updated manually
	list( APPEND ${TS_TARGETS} "${_dummy_target_file}" )

	# add command that really updates .ts file from sources
	add_custom_command(
		OUTPUT
			"${_dummy_target_file}"
		COMMAND
			"${QT_LUPDATE_EXECUTABLE}" ${_lupdate_options} "${_pro_file}" -ts "${_ts_file_absolute}"
		DEPENDS
			${_source_files}
			${_pro_file}
		)

	# run lupdate once if .ts file not exists
	if ( NOT EXISTS "${_ts_file_absolute}" )
		execute_process( COMMAND "${QT_LUPDATE_EXECUTABLE}" ${_lupdate_options} "${_pro_file}" -ts "${_ts_file_absolute}" )
	endif ( NOT EXISTS "${_ts_file_absolute}" )

	# generate .qm from .ts
	grim_add_translation( ${QM_FILE} "${OUTPUT_PATH}" "${TS_FILE}" )

endmacro( grim_create_translation )



# Second part of macro above.
# Creates rule to generate .qm file from .ts file.
#
# Usage:
#
#   grim_add_translation( QM_FILE TS_FILE )
#
#   - QM_FILE - out variable, .qm file that will be generated
#   - TS_FILE - in variable, .ts file from which .qm file will be generated

macro( grim_add_translation QM_FILE OUTPUT_PATH TS_FILE )
	set( _qm_file )

	set( _output_path "${OUTPUT_PATH}" )
	if ( _output_path )
		set( _qm_file "${CMAKE_CURRENT_BINARY_DIR}/${OUTPUT_PATH}" )
	else ( _output_path )
		get_filename_component( _ts_file_absolute "${TS_FILE}" ABSOLUTE )
		get_filename_component( _qm_filename_we "${_ts_file_absolute}" NAME_WE )
		set( _qm_file "${CMAKE_CURRENT_BINARY_DIR}/${_qm_filename_we}.qm" )
	endif ( _output_path )

	add_custom_command(
		OUTPUT
			"${_qm_file}"
		COMMAND
			${QT_LRELEASE_EXECUTABLE} -silent "${_ts_file_absolute}" -qm "${_qm_file}"
		DEPENDS 
			"${_ts_file_absolute}"
		)

	set( ${QM_FILE} "${_qm_file}" )
endmacro( grim_add_translation )




macro( grim_remove_extension FILENAME_WE FILENAME )
	string( LENGTH "${FILENAME}" _length )
	math( EXPR _pos "${_length} - 1" )

	set( ${FILENAME_WE} )

	while ( 1 )
		if ( _pos LESS 0 )
			break()
		endif ( _pos LESS 0 )

		string( SUBSTRING "${FILENAME}" ${_pos} 1 _char )

		if ( _char STREQUAL "/" )
			break()
		endif ( _char STREQUAL "/" )

		if ( _char STREQUAL "." )
			string( SUBSTRING "${FILENAME}" 0 ${_pos} ${FILENAME_WE} )
			break()
		endif ( _char STREQUAL "." )

		math( EXPR _pos "${_pos} - 1" )
	endwhile( 1 )

	if ( NOT ${FILENAME_WE} )
		set( ${FILENAME_WE} "${FILENAME}" )
	endif ( NOT ${FILENAME_WE} )
endmacro( grim_remove_extension )




# Macro that adds precompiled headers to the target.
#
# Usage:
#
#   grim_add_precompiled_headers( TARGET PRECOMPILED_HEADER [source1 source2 ...] )
#
#   - TARGET             - in variable, target to add precompiled headers support to
#   - PRECOMPILED_HEADER - in variable, path to header to precompile
#   - [sources ...]      - in variables, list of sources to add precompiled header usage to,
#                          usually, these are all target sources, but could be exceptions.
#
# Example:
#
#   add_executable( myapp ${mysources} )
#   grim_add_precompiled_headers( myapp precompiled_headers.h ${mysources} )

macro( grim_add_precompiled_headers TARGET PRECOMPILED_HEADER )

	# check that CMAKE_BUILD_TYPE was set
	if ( NOT CMAKE_BUILD_TYPE )
		message( FATAL_ERROR
			"No CMAKE_BUILD_TYPE specified for target: ${TARGET}\n" )
	endif ( NOT CMAKE_BUILD_TYPE )

	# Current build type as suffix to cmake variables
	string( TOUPPER ${CMAKE_BUILD_TYPE} _build_type )

	# Setting file names
	set( _gch_name PrecompiledHeaders )
	set( _gch_file_dir "${CMAKE_CURRENT_BINARY_DIR}/gch" )
	if ( MSVC )
		set( _gch_ext "pch" )
	else ( MSVC )
		set( _gch_ext "gch" )
	endif ( MSVC )
	set( _gch_file_path "${_gch_file_dir}/${_gch_name}.${_gch_ext}" )
	get_filename_component( _ph_absolute_path "${PRECOMPILED_HEADER}" ABSOLUTE )

	# MSVC requires additionally object file
	if ( MSVC )
		set( _gch_object_file_path ${_gch_file_dir}/${_gch_name}.obj )
	endif ( MSVC )

	get_target_property( _target_type ${TARGET} TYPE )
	if( ${_target_type} STREQUAL "SHARED_LIBRARY" )
		set( _additional_flags ${CMAKE_SHARED_LIBRARY_CXX_FLAGS} )
	endif( ${_target_type} STREQUAL "SHARED_LIBRARY" )

	# Gathering include information into _include_flags
	set( _include_flags )
	get_directory_property( _include_directories INCLUDE_DIRECTORIES )
	foreach( _include ${_include_directories} )
		if ( MSVC )
			list( APPEND _include_flags "/I${_include}" )
		else ( MSVC )
			list( APPEND _include_flags "-I${_include}" )
		endif ( MSVC )
	endforeach( _include )

	# Gathering compile flags into _compile_flags
	set( _compile_flags ${CMAKE_CXX_FLAGS} ${CMAKE_CXX_FLAGS_${_build_type}} )
	separate_arguments( _compile_flags )
	get_target_property( _target_compile_flags ${TARGET} COMPILE_FLAGS )
	if ( _target_compile_flags )
		set( _compile_flags ${_compile_flags} ${_target_compile_flags} )
	endif ( _target_compile_flags )

	# Gathering definition flags into _definition_flags
	set( _definition_flags )
	get_directory_property( _definitions "COMPILE_DEFINITIONS" )
	foreach( _def ${_definitions} )
		list( APPEND _definition_flags "-D${_def}" )
	endforeach( _def )
	get_directory_property( _definitions "COMPILE_DEFINITIONS_${_build_type}" )
	foreach( _def ${_definitions} )
		list( APPEND _definition_flags "-D${_def}" )
	endforeach( _def )

	# Generate precompiled header
	if ( MSVC )
		# HACK: Don't know how to obtain target's pdb file.
		get_target_property( _target_location ${TARGET} ${_build_type}_LOCATION )
		get_filename_component( _target_filename "${_target_location}" NAME )
		grim_remove_extension( _target_filename_we "${_target_filename}" )

		grim_get_target_output_directories( _interface_directory _runtime_directory ${TARGET} )
		if ( _target_type STREQUAL "EXECUTABLE" )
			set( _target_pdb_directory "${_runtime_directory}" )
		elseif ( _target_type STREQUAL "STATIC_LIBRARY" )
			set( _target_pdb_directory "${_interface_directory}" )
		else ( _target_type STREQUAL "EXECUTABLE" )
			set( _target_pdb_directory "${_runtime_directory}" )
		endif ( _target_type STREQUAL "EXECUTABLE" )

		set( _target_pdb "${_target_pdb_directory}/${_target_filename_we}.pdb" )

		add_custom_command(
			OUTPUT ${_gch_object_file_path}
			COMMAND ${CMAKE_COMMAND} -E make_directory ${_gch_file_dir}
			COMMAND ${CMAKE_CXX_COMPILER} ${_include_flags} ${_compile_flags} ${_definition_flags} ${_additional_flags}
				-c /Yc /Fp${_gch_file_path} /Fo${_gch_object_file_path} /Fd${_target_pdb} /TP ${_ph_absolute_path}
			DEPENDS ${_ph_absolute_path}
		)
	else ( MSVC )
		add_custom_command(
			OUTPUT ${_gch_file_path}
			COMMAND ${CMAKE_COMMAND} -E make_directory ${_gch_file_dir}
			COMMAND ${CMAKE_CXX_COMPILER} ${_include_flags} ${_compile_flags} ${_definition_flags} ${_additional_flags}
				-x c++-header -c ${_ph_absolute_path} -o ${_gch_file_path}
			DEPENDS ${_ph_absolute_path}
		)
	endif ( MSVC )

	# Setting sources dependencies
	if ( MSVC )
		set_source_files_properties( ${ARGN} PROPERTIES OBJECT_DEPENDS ${_gch_object_file_path} )
	else ( MSVC )
		set_source_files_properties( ${ARGN} PROPERTIES OBJECT_DEPENDS ${_gch_file_path} )
	endif ( MSVC )

	# Adding global compile flags to the target
	# If no sources was given than PrecompiledHeader file will not be created, so we should skip dependency
	set( _temp_argn ${ARGN} )
	list( LENGTH _temp_argn _sources_count )
	if ( NOT ${_sources_count} EQUAL 0 )
		get_target_property( _target_compile_flags ${TARGET} COMPILE_FLAGS )
		if ( NOT _target_compile_flags )
			set( _target_compile_flags )
		endif ( NOT _target_compile_flags )

		if ( MSVC )
			set_target_properties( ${TARGET} PROPERTIES COMPILE_FLAGS "${_target_compile_flags} -FI${PRECOMPILED_HEADER} -Yu${PRECOMPILED_HEADER} -Fp${_gch_file_path}" )
		else ( MSVC )
			set_target_properties( ${TARGET} PROPERTIES COMPILE_FLAGS "${_target_compile_flags} -include ${_gch_name} -Winvalid-pch" )
		endif ( MSVC )
	endif ( NOT ${_sources_count} EQUAL 0 )

	include_directories( BEFORE ${_gch_file_dir} )

endmacro( grim_add_precompiled_headers )




macro( grim_locate_translations TRANSLATIONS DIRECTORY PREFIX )
	set( ${TRANSLATIONS} )
	file( GLOB _ts_files RELATIVE "${DIRECTORY}" "${DIRECTORY}/${PREFIX}*.ts" )
	foreach ( _ts_file ${_ts_files} )
		string( REPLACE "${PREFIX}" "" _language "${_ts_file}" )
		string( REPLACE ".ts" "" _language "${_language}" )
		string( STRIP "${_language}" _language )
		string( LENGTH "{_language}" _language_length )
		if ( _language_length GREATER 0 )
			list( APPEND ${TRANSLATIONS} "${_language}" )
		endif ( _language_length GREATER 0 )
	endforeach ( _ts_file ${_ts_files} )
endmacro( grim_locate_translations PATTERN )




macro( grim_get_target_output_directories INTERFACE_DIRECTORY RUNTIME_DIRECTORY TARGET )
	get_target_property( _target_type ${TARGET} TYPE )

	if ( "${_target_type}" STREQUAL "STATIC_LIBRARY" )
		get_target_property( _target_interface_output_dir ${TARGET} ARCHIVE_OUTPUT_DIRECTORY )
		if ( NOT _target_interface_output_dir )
			set( _target_interface_output_dir ${CMAKE_ARCHIVE_OUTPUT_DIRECTORY} )
		endif ( NOT _target_interface_output_dir )

		set( ${INTERFACE_DIRECTORY} "${_target_interface_output_dir}" )
		set( ${RUNTIME_DIRECTORY} "" )
	elseif ( "${_target_type}" STREQUAL "SHARED_LIBRARY" OR "${_target_type}" STREQUAL "EXECUTABLE" )
		if ( WIN32 )
			get_target_property( _target_runtime_output_dir ${TARGET} RUNTIME_OUTPUT_DIRECTORY )
			if ( NOT _target_runtime_output_dir )
				set( _target_runtime_output_dir ${CMAKE_RUNTIME_OUTPUT_DIRECTORY} )
			endif ( NOT _target_runtime_output_dir )

			get_target_property( _target_interface_output_dir ${TARGET} ARCHIVE_OUTPUT_DIRECTORY )
			if ( NOT _target_interface_output_dir )
				set( _target_interface_output_dir ${CMAKE_ARCHIVE_OUTPUT_DIRECTORY} )
			endif ( NOT _target_interface_output_dir )
		else ( WIN32 )
			get_target_property( _target_runtime_output_dir ${TARGET} LIBRARY_OUTPUT_DIRECTORY )
			if ( NOT _target_runtime_output_dir )
				set( _target_runtime_output_dir ${CMAKE_LIBRARY_OUTPUT_DIRECTORY} )
			endif ( NOT _target_runtime_output_dir )

			set( _target_interface_output_dir ${_target_runtime_output_dir} )
		endif ( WIN32 )

		set( ${INTERFACE_DIRECTORY} "${_target_interface_output_dir}" )
		set( ${RUNTIME_DIRECTORY} "${_target_runtime_output_dir}" )
	else ( ( "${_target_type}" STREQUAL "STATIC_LIBRARY" ) )
		message( FATAL_ERROR "Resolving output directories allowed only for static, shared libraries and executables" )
	endif ( "${_target_type}" STREQUAL "STATIC_LIBRARY" )
endmacro( grim_get_target_output_directories )




macro( grim_get_target_libraries INTERFACE_LIBRARY RUNTIME_LIBRARY TARGET )
	get_target_property( _target_type ${TARGET} TYPE )
	get_target_property( _target_output_name ${TARGET} OUTPUT_NAME )
	get_target_property( _target_prefix ${TARGET} PREFIX )
	get_target_property( _target_suffix ${TARGET} SUFFIX )

	if ( "${_target_type}" STREQUAL "STATIC_LIBRARY" )
		set( _target_interface_prefix ${_target_prefix} )
		if ( NOT _target_interface_prefix )
			set( _target_interface_prefix ${CMAKE_STATIC_LIBRARY_PREFIX} )
		endif ( NOT _target_interface_prefix )

		set( _target_interface_suffix ${_target_suffix} )
		if ( NOT _target_interface_suffix )
			set( _target_interface_suffix ${CMAKE_STATIC_LIBRARY_SUFFIX} )
		endif ( NOT _target_interface_suffix )

		get_target_property( _target_interface_output_dir ${TARGET} ARCHIVE_OUTPUT_DIRECTORY )
		if ( NOT _target_interface_output_dir )
			set( _target_interface_output_dir ${CMAKE_ARCHIVE_OUTPUT_DIRECTORY} )
		endif ( NOT _target_interface_output_dir )

		set( ${INTERFACE_LIBRARY} "${_target_interface_output_dir}/${_target_interface_prefix}${_target_output_name}${_target_interface_suffix}" )
		set( ${RUNTIME_LIBRARY} "" )
	elseif ( "${_target_type}" STREQUAL "SHARED_LIBRARY" )
		set( _target_runtime_prefix ${_target_prefix} )
		if ( NOT _target_runtime_prefix )
			set( _target_runtime_prefix ${CMAKE_SHARED_LIBRARY_PREFIX} )
		endif ( NOT _target_runtime_prefix )

		get_target_property( _target_runtime_suffix ${TARGET} SUFFIX )
		if ( NOT _target_runtime_suffix )
			set( _target_runtime_suffix ${CMAKE_SHARED_LIBRARY_SUFFIX} )
		endif ( NOT _target_runtime_suffix )

		if ( WIN32 )
			get_target_property( _target_runtime_output_dir ${TARGET} RUNTIME_OUTPUT_DIRECTORY )
			if ( NOT _target_runtime_output_dir )
				set( _target_runtime_output_dir ${CMAKE_RUNTIME_OUTPUT_DIRECTORY} )
			endif ( NOT _target_runtime_output_dir )

			#set( _target_interface_prefix ${CMAKE_STATIC_LIBRARY_PREFIX} )
			#set( _target_interface_suffix ${CMAKE_STATIC_LIBRARY_SUFFIX} )
			set( _target_interface_prefix "" )
			set( _target_interface_suffix ".lib" )

			get_target_property( _target_interface_output_dir ${TARGET} ARCHIVE_OUTPUT_DIRECTORY )
			if ( NOT _target_interface_output_dir )
				set( _target_interface_output_dir ${CMAKE_ARCHIVE_OUTPUT_DIRECTORY} )
			endif ( NOT _target_interface_output_dir )
		else ( WIN32 )
			get_target_property( _target_runtime_output_dir ${TARGET} LIBRARY_OUTPUT_DIRECTORY )
			if ( NOT _target_runtime_output_dir )
				set( _target_runtime_output_dir ${CMAKE_LIBRARY_OUTPUT_DIRECTORY} )
			endif ( NOT _target_runtime_output_dir )

			set( _target_interface_prefix ${_target_runtime_prefix} )
			set( _target_interface_suffix ${_target_runtime_suffix} )
			set( _target_interface_output_dir ${_target_runtime_output_dir} )
		endif ( WIN32 )

		set( ${INTERFACE_LIBRARY} "${_target_interface_output_dir}/${_target_interface_prefix}${_target_output_name}${_target_interface_suffix}" )
		set( ${RUNTIME_LIBRARY} "${_target_runtime_output_dir}/${_target_runtime_prefix}${_target_output_name}${_target_runtime_suffix}" )
	else ( ( "${_target_type}" STREQUAL "STATIC_LIBRARY" ) )
		message( FATAL_ERROR "Resolving library name allowed only for static and shared library targets" )
	endif ( "${_target_type}" STREQUAL "STATIC_LIBRARY" )
endmacro( grim_get_target_libraries )




macro( grim_add_class HEADERS SOURCES CLASSNAME )
	set( _is_header_exists )
	set( _class_header "${CLASSNAME}.h" )
	if ( EXISTS "${_class_header}" )
		set( _is_header_exists YES )
		list( APPEND ${HEADERS} "${_class_header}" )
	endif ( EXISTS "${_class_header}" )

	set( _is_source_exists )
	set( _class_source "${CLASSNAME}.cpp" )
	if ( EXISTS "${_class_source}" )
		set( _is_source_exists YES )
		list( APPEND ${SOURCES} "${_class_source}" )
	endif ( EXISTS "${_class_source}" )

	if ( NOT _is_header_exists AND NOT _is_source_exists )
		message( FATAL_ERROR "grim_add_class() : Not header nor source files found for class: ${CLASSNAME}" )
	endif ( NOT _is_header_exists AND NOT _is_source_exists )
endmacro( grim_add_class )




macro( grim_add_classes HEADERS SOURCES )
	set( _is_setting_root_dir )
	set( _is_reading_files )
	set( _current_root_dir )

	foreach( _cmd ${ARGN} )
		set( _continue )

		if ( "${_cmd}" STREQUAL "ROOT_DIR" )
			set( _continue YES )
			set( _is_setting_root_dir YES )
		endif ( "${_cmd}" STREQUAL "ROOT_DIR" )

		if ( NOT _continue )
			if ( _is_setting_root_dir )
				set( _continue YES )
				set( _is_setting_root_dir )
				set( _current_root_dir "${_cmd}" )
				if ( NOT EXISTS "${_current_root_dir}" )
					message( FATAL_ERROR "grim_add_classes() : Directory not exists: ${_current_root_dir}" )
				endif ( NOT EXISTS "${_current_root_dir}" )
			endif ( _is_setting_root_dir )
		endif ( NOT _continue )

		if ( NOT _continue )
			if ( NOT _current_root_dir )
				message( FATAL_ERROR "grim_add_classes() : ROOT_DIR was not specified" )
			endif ( NOT _current_root_dir )

			set( _file "${_current_root_dir}/${_cmd}" )
			get_filename_component( _file_ext "${_file}" EXT )
			if ( NOT _file_ext )
				# assuming that this is class name
				grim_add_class( ${HEADERS} ${SOURCES} "${_file}" )
			elseif ( "${_file_ext}" STREQUAL ".h" )
				# this is a header
				list( APPEND ${HEADERS} "${_file}" )
			elseif ( "${_file_ext}" STREQUAL ".cpp" )
				# this is a source
				list( APPEND ${SOURCES} "${_file}" )
			endif ( NOT _file_ext )
		endif ( NOT _continue )
	endforeach( _cmd ${ARGN} )
endmacro( grim_add_classes HEADERS SOURCES )
